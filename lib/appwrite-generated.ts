/**
 * AUTO-GENERATED APPWRITE CONFIGURATION
 * 
 * Generated from schema/schema.ts
 * Do not edit this file directly - run 'npm run generate:appwrite' instead
 */

import { Client, Databases } from 'node-appwrite';

// Schema version for migration compatibility
export const SCHEMA_VERSION = '1.0.0';

// Initialize Appwrite client
export const client = new Client()
  .setEndpoint(process.env.APPWRITE_ENDPOINT || 'https://nyc.cloud.appwrite.io/v1')
  .setProject(process.env.APPWRITE_PROJECT_ID || 'college-football-fantasy-app')
  .setKey(process.env.APPWRITE_API_KEY);

export const databases = new Databases(client);
export const DATABASE_ID = process.env.APPWRITE_DATABASE_ID || 'college-football-fantasy';

// Collection IDs derived from schema
export const COLLECTIONS = {
  COLLEGE_PLAYERS: 'college_players',
  TEAMS: 'teams',
  GAMES: 'games',
  RANKINGS: 'rankings',
  LEAGUES: 'leagues',
  USER_TEAMS: 'user_teams',
  LINEUPS: 'lineups',
  AUCTIONS: 'auctions',
  BIDS: 'bids',
  PLAYER_STATS: process.env.NEXT_PUBLIC_APPWRITE_COLLECTION_PLAYER_STATS || 'player_stats', // Legacy hardcoded fallback
  USERS: 'users',
  ACTIVITY_LOG: 'activity_log',
} as const;

// Collection metadata for validation and tooling
export const COLLECTION_METADATA = {
  college_players: {
    id: 'college_players',
    name: 'College Players',
    description: 'Player roster data from Power 4 conferences',
    attributeCount: 16,
    indexCount: 7,
    requiredAttributes: ['name', 'position', 'team', 'conference'],
  },
  teams: {
    id: 'teams',
    name: 'Teams',
    description: 'Power 4 conference team information',
    attributeCount: 10,
    indexCount: 3,
    requiredAttributes: ['name', 'abbreviation', 'conference'],
  },
  games: {
    id: 'games',
    name: 'Games',
    description: 'College football game schedule and results',
    attributeCount: 14,
    indexCount: 6,
    requiredAttributes: ['week', 'season', 'season_type', 'home_team', 'away_team', 'start_date'],
  },
  rankings: {
    id: 'rankings',
    name: 'Rankings',
    description: 'AP Top 25 and other poll rankings',
    attributeCount: 7,
    indexCount: 5,
    requiredAttributes: ['week', 'season', 'poll_type', 'team', 'rank'],
  },
  leagues: {
    id: 'leagues',
    name: 'Leagues',
    description: 'Fantasy football leagues',
    attributeCount: 14,
    indexCount: 4,
    requiredAttributes: ['name', 'commissioner', 'season', 'maxTeams', 'draftType', 'gameMode', 'status'],
  },
  user_teams: {
    id: 'user_teams',
    name: 'Rosters',
    description: 'Fantasy team rosters within leagues',
    attributeCount: 13,
    indexCount: 4,
    requiredAttributes: ['leagueId', 'userId', 'teamName'],
  },
  lineups: {
    id: 'lineups',
    name: 'Lineups',
    description: 'Weekly fantasy lineups',
    attributeCount: 7,
    indexCount: 3,
    requiredAttributes: ['rosterId', 'week', 'season'],
  },
  auctions: {
    id: 'auctions',
    name: 'Auctions',
    description: 'Auction draft sessions',
    attributeCount: 8,
    indexCount: 2,
    requiredAttributes: ['leagueId', 'status'],
  },
  bids: {
    id: 'bids',
    name: 'Bids',
    description: 'Auction bid history',
    attributeCount: 6,
    indexCount: 4,
    requiredAttributes: ['auctionId', 'playerId', 'teamId', 'amount', 'timestamp'],
  },
  player_stats: {
    id: process.env.NEXT_PUBLIC_APPWRITE_COLLECTION_PLAYER_STATS || 'player_stats', // Legacy hardcoded fallback
    name: 'Player Stats',
    description: 'Game-by-game player statistics',
    attributeCount: 8,
    indexCount: 4,
    requiredAttributes: ['playerId', 'gameId', 'week', 'season'],
  },
  users: {
    id: 'users',
    name: 'Users',
    description: 'Application users',
    attributeCount: 7,
    indexCount: 3,
    requiredAttributes: ['authId', 'email'],
  },
  activity_log: {
    id: 'activity_log',
    name: 'Activity Log',
    description: 'System activity and audit trail',
    attributeCount: 7,
    indexCount: 4,
    requiredAttributes: ['action', 'timestamp'],
  },
};

/**
 * Get collection ID with type safety
 */
export function getCollectionId(name: keyof typeof COLLECTIONS): string {
  return COLLECTIONS[name];
}

/**
 * Validate that all required collections exist
 */
export async function validateCollections(): Promise<{ valid: boolean; missing: string[] }> {
  try {
    const response = await databases.listCollections(DATABASE_ID);
    const existingIds = new Set(response.collections.map(c => c.$id));
    
    const requiredCollections = Object.values(COLLECTIONS);
    const missing = requiredCollections.filter(id => !existingIds.has(id));
    
    return { valid: missing.length === 0, missing };
  } catch (error) {
    console.error('Failed to validate collections:', error);
    return { valid: false, missing: Object.values(COLLECTIONS) };
  }
}

/**
 * Get collection metadata
 */
export function getCollectionMetadata(collectionId: string) {
  return COLLECTION_METADATA[collectionId as keyof typeof COLLECTION_METADATA];
}
