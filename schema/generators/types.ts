/**
 * TypeScript Type Generator
 * 
 * Generates TypeScript interfaces from the canonical schema
 */

import { SCHEMA, type SchemaAttribute, type AttributeType } from '../schema';
import fs from 'fs';
import path from 'path';

function mapAttributeToTypeScript(attr: SchemaAttribute): string {
  let tsType: string;
  
  switch (attr.type) {
    case 'string':
    case 'url':
    case 'email':
    case 'ip':
      tsType = 'string';
      break;
    case 'integer':
    case 'double':
      tsType = 'number';
      break;
    case 'boolean':
      tsType = 'boolean';
      break;
    case 'datetime':
      tsType = 'Date | string'; // Can be Date object or ISO string
      break;
    default:
      tsType = 'any';
  }
  
  if (attr.array) {
    tsType = `${tsType}[]`;
  }
  
  if (!attr.required) {
    tsType = `${tsType} | undefined`;
  }
  
  return tsType;
}

function generateCollectionInterface(collectionId: string): string {
  const collection = SCHEMA[collectionId];
  const interfaceName = collectionId.split('_').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1)
  ).join('');
  
  let interfaceCode = `/**\n * ${collection.description}\n */\nexport interface ${interfaceName} {\n`;
  
  // Add Appwrite system fields
  interfaceCode += `  $id: string;\n`;
  interfaceCode += `  $collectionId: string;\n`;
  interfaceCode += `  $databaseId: string;\n`;
  interfaceCode += `  $createdAt: string;\n`;
  interfaceCode += `  $updatedAt: string;\n`;
  interfaceCode += `  $permissions: string[];\n\n`;
  
  // Add schema-defined attributes
  for (const attr of collection.attributes) {
    const tsType = mapAttributeToTypeScript(attr);
    const comment = attr.description ? `  /** ${attr.description} */\n` : '';
    interfaceCode += `${comment}  ${attr.key}: ${tsType};\n`;
  }
  
  interfaceCode += '}\n\n';
  
  // Add create interface (without system fields)
  const createInterfaceName = `Create${interfaceName}`;
  interfaceCode += `/**\n * Data required to create a new ${collection.name.toLowerCase()}\n */\nexport interface ${createInterfaceName} {\n`;
  
  for (const attr of collection.attributes) {
    if (!attr.required && attr.default !== undefined) continue; // Skip optional fields with defaults
    
    const tsType = mapAttributeToTypeScript(attr);
    const comment = attr.description ? `  /** ${attr.description} */\n` : '';
    interfaceCode += `${comment}  ${attr.key}: ${tsType};\n`;
  }
  
  interfaceCode += '}\n\n';
  
  // Add update interface (all fields optional)
  const updateInterfaceName = `Update${interfaceName}`;
  interfaceCode += `/**\n * Data for updating a ${collection.name.toLowerCase()}\n */\nexport interface ${updateInterfaceName} {\n`;
  
  for (const attr of collection.attributes) {
    const baseType = mapAttributeToTypeScript({...attr, required: false});
    const comment = attr.description ? `  /** ${attr.description} */\n` : '';
    interfaceCode += `${comment}  ${attr.key}?: ${baseType};\n`;
  }
  
  interfaceCode += '}\n\n';
  
  return interfaceCode;
}

export function generateTypes(): string {
  let typeCode = `/**
 * AUTO-GENERATED TYPES
 * 
 * Generated from schema/schema.ts
 * Do not edit this file directly - run 'npm run generate:types' instead
 */

// Schema version for compatibility checking
export const SCHEMA_VERSION = '${SCHEMA.VERSION || '1.0.0'}';

`;
  
  // Generate interfaces for each collection
  for (const collectionId of Object.keys(SCHEMA)) {
    typeCode += generateCollectionInterface(collectionId);
  }
  
  // Generate collection name constants
  typeCode += `/**\n * Collection name constants\n */\nexport const COLLECTIONS = {\n`;
  for (const collectionId of Object.keys(SCHEMA)) {
    const constantName = collectionId.toUpperCase();
    typeCode += `  ${constantName}: '${collectionId}' as const,\n`;
  }
  typeCode += '} as const;\n\n';
  
  // Generate type-safe collection access
  typeCode += `/**\n * Type-safe collection names\n */\nexport type CollectionName = keyof typeof COLLECTIONS;\nexport type CollectionId = typeof COLLECTIONS[CollectionName];\n\n`;
  
  // Generate union types for common enums
  typeCode += `/**\n * Common enum types derived from schema\n */\n`;
  
  // League status enum
  typeCode += `export type LeagueStatus = 'recruiting' | 'drafting' | 'active' | 'completed';\n`;
  typeCode += `export type DraftType = 'snake' | 'auction' | 'keeper';\n`;
  typeCode += `export type GameMode = 'standard' | 'ppr' | 'superflex';\n`;
  typeCode += `export type AuctionStatus = 'pending' | 'active' | 'paused' | 'completed';\n`;
  typeCode += `export type PlayerPosition = 'QB' | 'RB' | 'WR' | 'TE' | 'K' | 'DEF';\n`;
  typeCode += `export type Conference = 'SEC' | 'ACC' | 'Big 12' | 'Big Ten';\n`;
  typeCode += `export type PlayerYear = 'FR' | 'SO' | 'JR' | 'SR';\n\n`;
  
  return typeCode;
}

export function writeTypesToFile(): void {
  const typesContent = generateTypes();
  const outputPath = path.join(process.cwd(), 'types', 'generated.ts');
  
  // Ensure types directory exists
  const typesDir = path.dirname(outputPath);
  if (!fs.existsSync(typesDir)) {
    fs.mkdirSync(typesDir, { recursive: true });
  }
  
  fs.writeFileSync(outputPath, typesContent);
  console.log(`âœ… Generated TypeScript types: ${outputPath}`);
}

// CLI support
if (require.main === module) {
  writeTypesToFile();
}