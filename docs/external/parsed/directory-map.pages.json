{
  "fileId": "1SJHgcZrBx_ktqRObAhWe8YJMsUy-xMWr",
  "pagesCount": 1,
  "pages": [
    "Section 3 — Directory Maps: Style & Authoring\nGuide\nThis section defines what to draw,  how to lay it out, and    the legend you must use for directory maps. It’s\ntool‑agnostic and meant for consistent, reviewable diagrams during production.\nPurpose\nA directory map shows where things live in the repo and how code is organized by feature and    layer. Use\nit to: - Onboard teammates quickly. - Spot misplaced files and needless coupling. - Plan refactors and\nproduction hardening.\nWhich directory maps to create\nCreate them in this order (keep each as a separate diagram): 1. Global Repo Map — top‑level folders only\nplus 1–2 levels of depth for critical areas. 2. Client App Map (e.g., Next.js /app, /components, /lib)\n— show routes, layouts, shared UI. 3. Server/API Map (API routes, server actions, serverless functions) —\nshow handlers and adapters. 4. Data/Schema Map (types, schemas, queries, SDK wrappers) — show read/\nwrite boundaries. 5. Docs/Diagrams Map (/docs/diagrams) — show where specs and visuals live and\nhow they’re grouped.\nZoom‑ins: If a branch gets busy (e.g., Draft, League), create a per‑feature directory map with only that\nsubtree.\nRecommended layout\nDefault:Left → Right hierarchical tree (root on the left). This scans well on widescreens and\nhandles long names.\nAlternative:Top‑down if you have many nested levels but few siblings.\nClustering: Visually group by layer (Client / API / Data / Config / Docs). Use soft containers with\ntitles.\nDepth rule: Show at most 3 levels deep in any single diagram. If deeper, link to a zoom‑in diagram\nfor that branch.\nLegend (shapes, colors, lines, badges)\nUse this legend across all directory maps to stay consistent.\n• \n• \n• \n• \n1\n\nShapes\nFolder ( rectangle) — a directory.\nFile (page rectangle) — any source file.\nEntry point (double‑border rectangle) — page.tsx, layout.tsx, route.ts, server.ts, \nindex.ts.\nExternal module (hexagon) — 3rd‑party or external integration adapters.\nGenerated/Build (dashed rectangle) — artifacts like .next, dist, coverage.\nNote/Callout (sticky) — commentary (e.g., owner, TODO, risk).\nColors (by layer/cluster)\nClient/UI → Blue (e.g., /app, /components)\nAPI/Server → Teal  (e.g., /api, server actions, route handlers)\nData/Schema → Green  (types, schemas, queries, SDK wrappers)\nShared/Lib → Purple (utils, hooks, constants)\nConfig/Tooling → Yellow    (/config, /scripts, tsconfig.json)\nDocs/Design → Indigo (/docs, /diagrams)\nBuild/Generated → Grey   (excluded from ownership)\nExternal → Orange (SDKs, adapters)\nEdge semantics\nSolid connector — contains/“is inside”.\nDotted connector — generated from (e.g., schema → generated types) or alias to (symlink/path\nalias).\n(Optional overlay)Curved dashed arrow — important import/usage cross‑links between clusters\n(limit to 3–5 so it stays readable).\nBadges (tiny pills on files)\nPAGE / LAYOUT / ROUTE — framework entry files\nCLIENT / SERVER / RSC  — rendering/runtime markers\nEDGE / NODE — runtime target\nTYPE / SCHEMA / QUERY — data semantics\nTEST / STORY — quality assets\nCFG  — configuration\nASSET — static asset (img/svg/fonts)\nKeep badges short (≤5 chars) and place them top‑right on the node.\nWhat to include (content rules)\nTop level: show all first‑level folders. Hide vendor/build folders (list them in an “Excluded” sticky).\nClient App Map:\nShow   routes  and dynamic segments as folder names (e.g., /app/league/[id]/...).\n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n2\n\nMark entry files with PAGE, LAYOUT, ROUTE. Add CLIENT if the file has \"use client\".\nGroup shared UI under /components (atoms/molecules/organisms) and mark notable patterns\n(e.g., Dialog, Table, Chart).\nServer/API Map:\nShow route handlers (route.ts), server actions, and any adapters for external services.\nCall out Edge vs Node runtime where relevant.\nData/Schema Map:\nShow   types (*.d.ts, types/), schemas (Zod/Yup), queries (data access), and SDK wrappers\n(e.g., Appwrite client).\nMark WRITE boundaries (mutations) vs READ queries if helpful.\nDocs/Diagrams Map:\nShow category folders like project-map/, user-journeys/, architecture/, workflows/.\nKeep per‑diagram README/links visible so readers can open the right artifact.\nAuthoring steps (numbered, repeatable)\nPick scope & depth. Decide which of the five map types you’re drawing and cap depth to 3 levels.\nPlace the root. Add the repo name as the root node.\nAdd top‑level directories. Use  Folder nodes. Add a sticky labeled Excluded listing build/vendor\ndirs (e.g., node_modules, .next, dist).\nCluster by layer. Encapsulate related folders into Blue (Client), Teal (API), Green (Data), Purple\n(Shared), Yellow (Config), Indigo (Docs) containers.\nAdd critical files. Within each cluster, add Entry point files (double‑border) and core files (page/\ncomponents/hooks/types/queries).\nMark semantics with badges. Apply PAGE, LAYOUT, ROUTE, CLIENT, SERVER, RSC , \nEDGE, NODE, TYPE, SCHEMA, QUERY, TEST, CFG , ASSET appropriately.\nShow dynamic segments. For app routes, display {param} folders like [id]. If there’s a \ncatch‑all (e.g., [...slug]), annotate it with a small sticky.\nOptional overlays. Add up to 5 curved dashed arrows to show critical imports/usages across\nclusters (e.g., UI → Data queries). Label them tersely (e.g., uses, imports).\nRuntime and ownership notes. On key nodes, use stickies for runtime (Edge/Node), SSR/CSR/RSC,\nand owner  (team/member).\nLegend panel. Place the legend box in the lower right; reuse the same legend across all directory\nmaps.\nClarity pass. Enforce alignment, spacing, and label wrap. Avoid crossed lines. Collapse or link out\nwhen crowded.\nQA pass. Cross‑check against the actual repo tree; verify entry points and aliases.\nStamp & link. Date‑stamp the footer and include a link to the commit hash or release tag this map\nreflects.\nAcceptance criteria (quality bar)\nAccurate: Matches the repo at a known commit/tag.\nLegible: ≤3 levels deep; no visual clutter; legend present.\n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n• \n1. \n2. \n3. \n4. \n5. \n6. \n7. \n8. \n9. \n10. \n11. \n12. \n13. \n• \n• \n3\n\nSemantic: Badges and colors correctly describe runtime, role, or type.\nActionable: Highlights entry points and key cross‑links/aliases.\nConsistent: Same legend and color scheme used across all directory maps.\nDo’s & Don’ts\nDo - Keep one clear purpose per diagram. - Use zoom‑ins for busy branches. - Annotate runtime (EDGE/\nNODE) and rendering (CLIENT/RSC ) where it matters.\nDon’t   - Don’t show every file; focus on explainable structure. - Don’t mix logical flows (that’s for User\nJourneys), keep this structural. - Don’t exceed five overlay dependency arrows.\nOptional add‑ons\nPath alias box (e.g., @/components, @/lib) to clarify import roots.\nRisk/TODO stickies for branches slated for refactor.\nOwnership labels to make code reviews and on‑call easier.\nNext (when you’re ready): We can do System & Architecture Diagrams (containers/components/runtime,\nwith deployment environments) or Workflows (async jobs, cron, draft timers) in the same step‑by‑step\nstyle.\n• \n• \n• \n• \n• \n• \n4"
  ]
}